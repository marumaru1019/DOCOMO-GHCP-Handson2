# 作成済みコンテンツ一覧

このファイルは、既に作成済みのコンテンツを記録し、新規コンテンツ作成時の重複を防ぐためのものです。

---

## step15: GitHub Copilot の基礎

### ① チャット機能（example-1.md）
- **チャットビュー**
  - モード早見表（Ask/Edit/Agent の違い）
  - 基本的な使い方（チャットビューの開き方、質問の仕方）
  - コンテキストの追加方法（`#file`, `#selection`, `#codebase`等）
  - リクエストの編集と再試行
  - レスポンスの操作（挿入、コピー、新規ファイル作成）
- **インラインチャット**
  - 呼び出し方法（ショートカット：Mac `⌘I` / Windows `Ctrl+I`）
  - 基本的な使い方（コード選択→指示）
  - 提案の操作（Accept/Discard/再生成）
  - Fix using Copilot（エラー自動修正）
- **練習問題**
  - チャットビューでの質問、コード生成、テスト生成
  - インラインチャットでのリファクタリング、コメント追加

### ② ツール（example-2.md）
- **ツールとは**
  - `#`構文での呼び出し
  - チャット変数の参照
  - Agent mode での自動実行
- **基本ツール一覧（28個）**
  - コンテキスト参照系（`#file`, `#selection`, `#codebase`等）
  - 実行・確認系（`#runTests`, `#runCommands`, `#problems`等）
  - 外部連携系（`#fetch`, `#githubRepo`, `#extensions`等）
- **具体的な使い方（例題3つ）**
  - 例題1：`#terminalSelection` でエラー解決
  - 例題2：`#fetch` で Web ページ情報取得
  - 例題3：`#githubRepo` でライブラリ調査
- **Agent mode でのツール制御**
  - Tool Picker の使い方（🔧アイコン）
  - ツール制限の活用例（セキュリティ重視/効率重視/学習目的）
- **MCP サーバーでツール拡張**
  - MCP とは（Model Context Protocol の説明）
  - 導入メリット（手作業の会話化、再利用性、構成の見える化）
  - インストール方法3つ
    - 方法1：VS Code 拡張機能からインストール
    - 方法2：MCP Marketplace からインストール（プレビュー機能）
    - 方法3：手動で `mcp.json` 編集
  - 例題：Azure MCP Server で Bicep テンプレート作成
    - 拡張機能インストール
    - ツール有効化
    - `#bicepschema` での Bicep テンプレート生成（詳細なコード例含む）
  - その他の活用例（API バージョン確認、スキーマ情報取得）
- **練習問題**
  - 基本ツールの練習
  - エラー解析の練習
  - 情報収集の練習
  - MCP 拡張の練習

### ③ カスタマイズ（example-3.md）
- **カスタマイズとは**
  - 定義と目的（プロジェクト要件への適合、再利用可能なプロンプト管理）
- **カスタマイズの種類（4種類の比較表）**
  - カスタムインストラクション（`.github/copilot-instructions.md`）
  - パス別インストラクション（`.instructions.md`）
  - Prompts ファイル（`.prompt.md`）
  - カスタムチャットモード（`.chatmode.md`）
- **使い分けの指針**
  - Mermaid フローチャート（決定木形式）
  - 常時適用 vs 条件付き vs 手動実行 vs モード選択の判断基準
- **カスタマイズの使い方**
  - **4.1 カスタムインストラクション**
    - 使う場面（プロジェクト全体のルール統一）
    - 作成方法（設定→フォルダ作成→ファイル作成）
    - 含めるべき項目チェックリスト（8項目）
    - 詳細な例（EC サイトフロントエンド、Node.js バックエンド）
    - 自動生成機能の紹介
  - **4.2 パス別インストラクション**
    - 使う場面（領域別のルール適用）
    - 作成方法（コマンドパレット/UI から）
    - Front Matter 設定（`description`, `applyTo`）
    - ファイル構造例
    - glob パターンの使い方
  - **4.3 Prompts ファイル**
    - 使う場面（定型作業の効率化）
    - 作成方法（コマンドパレット/UI から）
    - Front Matter 設定（`mode`, `model`, `description`, `tools`）
    - 呼び出し方法3つ（コマンドパレット/チャット入力/再生ボタン）
    - ツール優先度の説明（Prompt file > chat mode > 既定）
    - 変数使用例（`${file}`等）
  - **4.4 カスタムチャットモード**
    - 使う場面（タスク特化環境）
    - 作成方法（コマンドパレット→保存場所選択）
    - Front Matter 設定（`description`, `tools`, `model`）
    - 例：計画立案モード（詳細な構成付き）
    - チャットモードの管理方法
- **練習問題（3問）**
  - 練習1：カスタムインストラクションの作成
  - 練習2：Prompts ファイルの作成
  - 練習3：カスタムチャットモードの作成
- **よくある質問（4問）**
  - Q1：どれから始めればいい？
  - Q2：ツールの優先順位は？
  - Q3：チームで共有するには？
  - Q4：ワークスペースとユーザープロファイルの違いは？

---

## step16: AI 開発ワークフローを構築する際のポイント

### ① 再現可能で信頼性の高いワークフローの構築（example-1.md）
- **現状の課題**
  - 場当たり的なプロンプト作成の問題点
  - 再現性の欠如と品質のばらつき
- **解決策：3層構造のフレームワーク**
  - Layer 1: Markdown プロンプトエンジニアリング
    - 5つの構成要素（役割、コンテキスト、思考構造、ツール統合、検証ゲート）
  - Layer 2: エージェント・プリミティブ
    - 6種類のプリミティブファイル（.instructions.md, .chatmode.md, .prompt.md, .spec.md, .memory.md, .context.md）
  - Layer 3: コンテキストエンジニアリング
    - セッション分割、コンテキストウィンドウ最適化
- **実践例の比較**
  - Before：単純なプロンプト（問題点の可視化）
  - After：構造化されたプロンプト（改善点の実例）
- **まとめ**
  - 3層の連携効果
  - 次のステップへの導線

### ② 適切なプロンプト設計（example-2.md）
- **プロンプト設計の重要性**
  - 構造化されたプロンプトの効果
- **プロンプト設計の5要素**
  - **3.1 役割の活性化（Role Activation）**
    - 専門的なペルソナ設定
    - 具体例（TypeScript エンジニア）
  - **3.2 コンテキストローディング（Context Loading）**
    - 必要な情報の明示的な提供
    - リンク参照の活用例
  - **3.3 構造化された思考（Structured Thinking）**
    - フェーズ分割とチェックリスト
    - 段階的なタスク実行
  - **3.4 ツール統合（Tool Integration）**
    - ツールの明示的な指定
    - 期待される動作の説明
  - **3.5 バリデーションゲート（Validation Gates）**
    - 承認ポイントの設定
    - 自律性とコントロールのバランス
- **実践例：Todo CLI アプリ作成**
  - セットアップフェーズ
  - コーディング規約の作成（coding_standards.md）
  - アプリケーション実装
  - 実行結果
- **練習問題**
  - 練習1：プロンプトの改善
  - 練習2：独自のプロンプトテンプレート作成
- **まとめ**
  - 5要素の重要性
  - 実践での活用方法

### ③ 再利用可能なコンポーネントの構築（example-3.md）
- **再利用可能なコンポーネントとは**
  - エージェント・プリミティブの概念
  - 自然言語によるプログラミングの基盤
- **エージェント・プリミティブの種類と用途**
  - 6種類のプリミティブ（Mermaid 図解付き）
  - 各プリミティブの特徴（配置場所、トリガー、効果の比較表）
  - VS Code ネイティブサポートについての補足
- **それぞれのプリミティブの具体例**
  - **3.1 Instructions（インストラクション）**
    - TypeScript 開発ガイドライン例
    - 自動適用の効果（Mermaid フロー図）
    - Tips：applyTo パターンの活用
  - **3.2 Chat Mode（チャットモード）**
    - バックエンド開発者モード例
    - チャットモードの使い分け（4つの役割例）
    - ツール制限による境界設定
  - **3.3 Prompt（プロンプト）**
    - コードレビューワークフロー例
    - 5つのフェーズ構成
    - 実行方法
  - **3.4 Spec（仕様書）**
    - 機能仕様テンプレート
    - 8セクション構成（概要、機能要件、技術要件、データ設計等）
    - Spec ファイルの活用フロー（Mermaid 図解）
  - **3.5 Memory（メモリ）**
    - プロジェクトメモリ例
    - 学習記録の構造（セキュリティ、パフォーマンス、API設計）
    - よくある失敗パターンと成功パターン
    - Memory ファイルの効果
  - **3.6 Context（コンテキスト）**
    - API ドキュメント例
    - コンテキストヘルパーの構造
    - 使用方法（リンク参照）
- **練習問題**
  - 練習1：Instructions ファイルの作成
  - 練習2：Chat Mode の設計
  - 練習3：Workflow の自動化
- **まとめ**
  - 6種類のプリミティブの役割
  - 次のステップ（コンテキスト設計）への導線

### ④ コンテキスト設計（セッション分割）（example-4.md）
- **コンテキスト設計とは**
  - コンテキストウィンドウの制限
  - セッション分割の概念
- **なぜセッション分割が必要か**
  - コンテキストウィンドウの制限（Mermaid 図解）
  - セッション分割の効果（比較表）
- **セッション分割の基本戦略**
  - **3.1 開発フェーズによる分割**
    - 新機能開発の例（5セッション構成）
    - セッション1：要件定義
    - セッション2：設計
    - セッション3：実装
    - セッション4：テスト
    - セッション5：ドキュメント
    - 各セッションの詳細なプロンプト例
  - **3.2 タスクの性質による分割**
    - リサーチとアクションの分離例
    - 分離の効果
  - **3.3 複雑さによる分割**
    - モジュール単位の分割例（データモデル、ビジネスロジック、API）
- **セッション間の情報伝達**
  - **4.1 引き継ぎドキュメントの作成**
    - 引き継ぎ方法の例
    - 効果的な引き継ぎのポイント（比較表）
    - 良い引き継ぎ例
- **実践例：セッション分割の完全なワークフロー**
  - バグ修正タスクの5セッション構成
  - セッション1：問題の特定と分析
  - セッション2：修正方針の決定
  - セッション3：修正の実装
  - セッション4：テストの追加
  - セッション5：ドキュメント更新
  - セッション分割の効果（Mermaid フロー図）
- **セッション分割のベストプラクティス**
  - **6.1 いつセッションを分割すべきか**
    - 分割の判断基準（推奨5ケース、不要3ケース）
  - **6.2 セッション分割の落とし穴**
    - よくある問題と解決策（比較表）
- **練習問題**
  - 練習1：基本的なセッション分割
  - 練習2：引き継ぎドキュメントの作成
  - 練習3：セッション分割の最適化
- **まとめ**
  - セッション分割の効果
  - 3つの重要要素の統合
  - 次のステップへの導線
