---
title: "② コンテキストファイルの作成"
categories: [AI開発ワークフロー, マルチリポジトリ]
weight: 2
tags: [.context.md, ドキュメント, API仕様, データモデル]
---

## 1. コンテキストファイルとは？

**コンテキストファイル（`.context.md`）** は、GitHub Copilot が効率的に参照できるように構造化されたドキュメントです。プロジェクトのAPI定義書、データモデル、アーキテクチャ図などを事前に整理しておくことで、AI がプロンプトを受けたときに必要な情報をすぐに取得できます。

マルチリポジトリ環境では、フロントエンドとバックエンドで共通の参照ドキュメントを `.context.md` ファイルとして作成することで、整合性を保ちやすくなります。

> **ポイント**
>
> * **構造化された参照ドキュメント** … API仕様、データモデル、アーキテクチャ図を整理
> * **効率的なコンテキスト提供** … プロンプトでリンク参照するだけで必要な情報を提供
> * **マルチリポジトリの整合性** … フロントエンドとバックエンドで共通認識を形成
> * **保守性の向上** … 仕様変更を一箇所にまとめて管理

---

## 2. コンテキストファイルの配置と役割

### 2.1 ディレクトリ構造

各リポジトリの `docs/context/` ディレクトリにコンテキストファイルを配置します。API仕様はバックエンドで一元管理し、フロントエンドからクロスリポジトリ参照します。

```
Workspace/
├── helpdesk-frontend/
│   ├── docs/
│   │   └── context/
│   │       └── auth-flow.context.md          # 認証フロー（フロントエンド視点）
│   └── ...
└── helpdesk-backend/
    ├── docs/
    │   └── context/
    │       ├── api-specification.context.md  # REST API仕様（単一の情報源）
    │       └── database-schema.context.md    # データベーススキーマ
    └── ...
```

> 💡 **設計のポイント**: API仕様はバックエンドで一元管理し、フロントエンドは `#file:../helpdesk-backend/docs/context/api-specification.context.md` でクロスリポジトリ参照します。これにより、API仕様の更新を一箇所で管理でき、フロントエンドとバックエンドの不整合を防げます。

> ⚠️ **注意事項**
>
> コンテキストファイルは、本来であれば**チームメンバーが手作業で作成**するか、**GitHub Copilot に叩き台を作らせて、整合性のチェックは必ず人間が行う**必要があります。
>
> - **AI生成の限界**: GitHub Copilot はプロジェクトの全容を完璧に理解しているわけではありません
> - **検証が必須**: 生成された内容が実際のコード、API仕様、データモデルと一致しているか確認してください
> - **段階的な改善**: 最初は基本的な内容から始め、開発を進めながら随時更新していくことが重要です
>
> このセクションでは、GitHub Copilot を使って**簡易的に作成する方法**を使用しますが、実際のプロジェクトでは必ず内容の正確性を検証してください。

---

## 3. コンテキストファイルの作成例

### :pen: 例題1 - API仕様書（バックエンド）

**バックエンドリポジトリ**でAPI仕様書を作成します。このファイルがフロントエンドとバックエンドの両方から参照される単一の情報源になります。

**プロンプト例:**

```text
#codebase APIエンドポイントを調べて、API仕様書（docs/context/api-specification.context.md）を作成してください。

以下の情報を含めてください：
- ベースURL（開発環境と本番環境）
- 認証方法（JWT認証フロー）
- 主要エンドポイント一覧（認証、チケット、ナレッジ記事、ユーザー管理）
- HTTPステータスコードの使い分け
- エラーレスポンス形式
- ページネーションとフィルタリング

バックエンドのルーターファイル（app/routers/）とスキーマ（app/schemas/）を参照してください。
```

**ステップ2: 生成された内容を確認**

Copilot が以下のような構造でファイルを生成します：

````markdown
# API 概要

社内ヘルプアプリのバックエンドAPIの概要。

## ベースURL
- **開発環境**: `http://localhost:8000`
- **本番環境**: `https://api.helpdesk.example.com`

## 認証
JWT トークンによる認証が必要です。

## 主要エンドポイント
### 認証（Authentication）
| メソッド | パス | 説明 | 認証 |
|---------|------|------|------|
| POST | `/auth/login` | ログイン | 不要 |
| GET | `/auth/me` | 現在のユーザー情報取得 | 必要 |

### チケット（Tickets）
| メソッド | パス | 説明 | 認証 |
|---------|------|------|------|
| GET | `/tickets` | チケット一覧取得 | 必要 |
| POST | `/tickets` | チケット作成 | 必要 |
| PUT | `/tickets/{ticket_id}` | チケット更新 | 必要 |

（以下、ナレッジ記事、ユーザー管理、HTTPステータスコード、エラーレスポンス形式などが続く）
````

**ステップ3: 実際のコードと照合して検証**

生成された内容を実際のバックエンドコードと照合します：

1. **エンドポイントの確認**
   ```text
   #file:../helpdesk-backend/app/routers/tickets.py

   このファイルのエンドポイント定義と、生成されたapi-overview.context.mdのチケットエンドポイント一覧を比較してください。相違点があれば指摘してください。
   ```

2. **レスポンススキーマの確認**
   ```text
   #file:../helpdesk-backend/app/schemas/ticket.py

   Pydanticスキーマと、ドキュメントのレスポンス形式が一致しているか確認してください。
   ```

3. **必要に応じて修正**
   - 不足しているエンドポイントを追加
   - 誤ったステータスコードを修正
   - 実際のフィールド名と型を反映

> ⚠️ **検証のポイント**: エンドポイントのパス、HTTPメソッド、認証要否、レスポンス形式が実装と完全に一致しているか確認してください。

---

### :pen: 例題2 - 認証フロー(フロントエンド)

フロントエンド開発者向けの認証フローを図解付きで説明するコンテキストファイルを作成します。

**プロンプト例:**

```text
#codebase 認証フローのドキュメント(docs/context/auth-flow.context.md)を作成してください。

以下を含めてください：
- 認証フロー全体のシーケンス図(Mermaid形式)
- localStorageへのトークン保存方法
- api-client.tsでのトークン使用方法
- AuthContextの実装パターン
- 保護されたルートの実装
- セキュリティ考慮事項

lib/auth-context.tsx、lib/api-client.ts、components/protected-route.tsx を参照してください。
```

### :robot: 出力例

````markdown
# 認証フロー

## 認証フロー概要（Mermaid図）

ユーザー → ログインUI → API Client → FastAPI → Database
のシーケンス図が生成される

## トークンの保存と管理
- localStorage への保存コード例
- api-client.ts でのトークン使用例

## Context API による認証状態管理
- AuthContext の実装パターン

## 保護されたルートの実装
- ProtectedRoute コンポーネント

(以下、セキュリティ考慮事項、トラブルシューティングなどが続く)
````

---

### :pen: 例題3 - データベーススキーマ(バックエンド)

**バックエンドリポジトリ**でデータベース構造を明確に文書化します。

**プロンプト例:**

```text
#codebase データベーススキーマのドキュメント(docs/context/database-schema.context.md)を作成してください。

以下を含めてください：
- ER図（Mermaid形式）でテーブル間のリレーションシップを表現
- 主要テーブル（users, tickets, comments, teams, categories）の詳細
- 各テーブルのカラム定義、制約、インデックス
- 1対多、多対多のリレーションシップ
- マイグレーション手順

app/models/ 配下のSQLAlchemyモデルを参照してください。
```

### :robot: 出力例

````markdown
# データベーススキーマ

## ER図（Mermaid）

USERS, TICKETS, COMMENTS, TEAMS, CATEGORIES, TAGS, ARTICLES
のリレーションシップを示すER図が生成される

## テーブル詳細

### users テーブル
- カラム定義、制約、インデックス

### tickets テーブル
- カラム定義、ステータス、優先度

### comments テーブル
- チケットへのコメント

（以下、teams, categories, tags, knowledge_articles などの詳細が続く）

## リレーションシップ
- 1対多のリレーションシップ表
- 多対多のリレーションシップ表

## マイグレーション
- 初期マイグレーション手順
- テーブル作成順序
````

---


## :memo: 練習

### 練習1: コンテキストファイルの作成と検証

1. **API概要ファイルの作成**
   - Agent mode で `api-overview.context.md` を作成
   - バックエンドのルーターファイル（`app/routers/`）を参照させる
   - 生成された内容を実際のエンドポイントと照合

2. **検証プロンプトの実行**
   ```text
   #file:../helpdesk-backend/app/routers/tickets.py
   #file:docs/context/api-overview.context.md

   このファイルのエンドポイント定義と、api-overview.context.mdのチケットエンドポイント一覧を比較してください。相違点があれば指摘してください。
   ```

3. **不一致箇所の修正**
   - Copilot が指摘した相違点を手動で修正
   - 再度検証して整合性を確認

### 練習2: クロスリポジトリでの活用

1. **フロントエンドでの実装**
   ```text
   #file:../helpdesk-backend/docs/context/api-specification.context.md

   チケット更新機能を実装してください。PUT /tickets/{ticket_id} を呼び出すAPIクライアント関数を作成してください。
   ```

2. **型の一貫性確認**
   ```text
   #file:lib/types.ts
   #file:../helpdesk-backend/app/schemas/ticket.py

   フロントエンドのTicket型と、バックエンドのPydanticスキーマが一致しているか確認してください。
   ```

> 💡 **重要**: コンテキストファイルは「AI が生成した叩き台」として扱い、必ず人間がレビューして正確性を担保してください。段階的に改善していくアプローチが効果的です。

---

## まとめ

* **GitHub Copilot の Agent mode** を活用してコンテキストファイルの叩き台を効率的に作成
* **優先度の高い4つのファイル** - API概要、API仕様、認証フロー、データベーススキーマから始める
* **必ず検証が必要** - AI生成の内容は実際のコードと照合し、整合性をチェック
* **段階的な改善** - 完璧を目指さず、基本から始めて徐々に充実させる
* **クロスリポジトリ参照** - `#file:` 構文でフロントエンドとバックエンドを相互参照
* **カスタムインストラクションとの連携** - コンテキストファイルをインストラクションから参照して常時活用

> ⚠️ **再確認**: コンテキストファイルは「本来人間が作成すべきドキュメント」です。GitHub Copilot は効率化のツールとして活用し、最終的な正確性は必ず人間が担保してください。

次のセクション「② カスタムインストラクションの作成」では、これらのコンテキストファイルを効果的に活用するためのプロジェクト固有ルールの定義方法を学びます。
