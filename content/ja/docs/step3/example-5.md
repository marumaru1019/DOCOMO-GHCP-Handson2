---
title: ⑤ エージェントワークフローの作成
categories: [AI開発ワークフロー, ワークフロー自動化]
weight: 5
tags: [prompt.md, SDLC, ワークフロー, 再利用性]
---

## 1. エージェントワークフローとは？

エージェントワークフロー（Agent Workflow）は、カスタムチャットモードを呼び出すための**再利用可能なタスクテンプレート**です。現実世界の「作業手順書」や「チェックリスト」のように、特定のタスクを一貫した品質で実行するための指示書として機能します。

> **ポイント**
>
> * **再利用可能なテンプレート** … 同じタスクを繰り返し実行する際の標準化
> * **チャットモードとの連携** … 特定のモード（architect / engineer / reviewer）で実行
> * **4つのセクション構造** … Context Loading / Deterministic Execution / Structured Output / Validation Gate
> * **SDLC の自動化** … specify → plan → implement → review の4段階ワークフロー

---

## 2. 5つのワークフローの設計

SDLC（Software Development Life Cycle）を5つのフェーズに分割し、それぞれにワークフローを作成します：

| ワークフロー | チャットモード | 目的 | 成果物 |
|------------|--------------|------|--------|
| **specify.prompt.md** | `architect` | 要件を仕様書に変換 | `[仕様書フォルダ]/[機能名]/[機能名].spec.md` |
| **plan.prompt.md** | `architect` | 技術設計書の作成 | `[仕様書フォルダ]/[機能名]/[機能名].plan.md` |
| **implement.prompt.md** | `frontend-engineer` / `backend-engineer` | コード実装 | ソースコード + テスト |
| **review.prompt.md** | `fullstack-reviewer` | 品質検証 | レビューレポート |
| **update-context.prompt.md** | `architect` | コンテキストファイル更新 | 更新されたコンテキストファイル |

---

## 3. ワークフロー実装例

### :pen: 例題1 - specify.prompt.md（仕様定義ワークフロー）

ユーザーの要望や課題を、ユーザーストーリー形式の仕様書に変換し、`.spec.md` ファイルとして保存するワークフローです。**技術的な詳細は含めず**、「誰が」「何をしたいか」「なぜ必要か」に焦点を当てます。

**ファイル:** `.github/prompts/specify.prompt.md`

````markdown
---
mode: architect
description: ユーザーの要望を要件定義に変換する（技術要素は一切含めない）
---

# 仕様定義ワークフロー

## Steps

### Step 1: Context Loading
- `#codebase` でプロジェクト概要を確認
- 既存の仕様書（`[仕様書フォルダ]/*/`）を検索
- ビジネス要件と類似機能を参考にする

### Step 2: Execution
ユーザーの要望を以下の観点で整理（**技術的な実装方法は一切含めない**）:

1. **ユーザーストーリー**: "As a [誰が], I want to [何を], So that [なぜ]"
2. **受け入れ条件**: ユーザーから見て何ができれば満たされるか
3. **ユーザーシナリオ**: ユーザーがどのような手順で操作するか
4. **ビジネス価値**: なぜこの機能が必要か、どんな効果があるか

**重要な制約**:
- ❌ 技術スタック（React, FastAPI, PostgreSQL等）には言及しない
- ❌ データベース設計やAPI設計には言及しない
- ❌ UIコンポーネント名や実装方法には言及しない
- ✅ あくまで「ユーザーにとって何ができるようになるか」に焦点を当てる

### Step 3: Structured Output
以下の形式で仕様書ドラフトをチャットで表示(実際の仕様書は作らない):

\```markdown
# [機能名] 仕様書

作成日: YYYY-MM-DD

## ユーザーストーリー
**As a** [役割（例: サポート担当者）]
**I want to** [実現したいこと（例: チケットを検索できる）]
**So that** [目的（例: 目的のチケットを素早く見つけられる）]

## 受け入れ条件
- [ ] [ユーザーができること1（例: 検索ボックスが表示されている）]
- [ ] [ユーザーができること2（例: キーワードを入力すると該当するチケットが表示される）]
- [ ] [ユーザーができること3（例: 検索結果が即座に反映される）]

## ユーザーシナリオ
1. **開始**: [ユーザーがどこから始めるか]
2. **アクション**: [ユーザーが何をするか]
3. **結果**: [ユーザーに何が表示されるか/体験できるか]
4. **完了**: [最終的にどうなるか]

## ビジネス価値
- **効率性**: [期待される効果（例: 検索時間を70%短縮）]
- **品質**: [期待される効果（例: 見落としリスクがゼロ）]
- **ユーザー満足度**: [期待される効果（例: ストレスなく探せる）]
\```

**この段階では以下を含めないこと**:
- 技術的な実装方法（API、データベース、フレームワーク等）
- UIコンポーネントの具体的な名前
- データモデルやスキーマ設計
- 実装の詳細や手順

### Step 4: Validation Gate (🚨 STOP)
**ここで必ずユーザーの承認を待つ**

仕様書ドラフトを提示し、以下を確認してもらう:
- [ ] ユーザーストーリーが明確か
- [ ] 受け入れ条件が具体的で測定可能か
- [ ] ユーザーシナリオが実際の使い方を反映しているか
- [ ] ビジネス価値が明確か
- [ ] **技術的な要素が含まれていないか**（重要）

- ✅ **承認された場合**: Step 5へ進む
- ❌ **修正が必要な場合**: Step 2に戻る

### Step 5: File Creation
承認後、`[仕様書フォルダ]/[機能名]/[機能名].spec.md` を作成する。

**次のステップ**: `/plan` で技術設計を作成（技術的な要素は次のフェーズで決定）
````
---

### :pen: 例題2 - plan.prompt.md（計画策定ワークフロー）

`.spec.md` ファイルを読み込み、技術設計＆タスク書を作成し、各リポジトリに配置するワークフローです。

**ファイル:** `.github/prompts/plan.prompt.md`

````markdown
---
mode: architect
description: 仕様書から実装計画を作成する
---

# 実装計画ワークフロー

## Steps

### Step 1: Context Loading
- 仕様書（`[仕様書フォルダ]/[機能名]/[機能名].spec.md`）を読み込み
- 各リポジトリのディレクトリ構造を確認
- `#codebase` で類似機能を検索

### Step 2: Execution
責務を分解し（フロントエンド/バックエンド）、変更ファイルをリストアップ。
実装順序と所要時間を見積もる。

### Step 3: Structured Output
以下の形式で技術設計書ドラフトをチャットで表示(実際の技術設計書は作らない):

\```markdown
# [機能名] 技術設計書

## バックエンド実装
- [ ] `app/models/[name].py` - [内容]
- [ ] `app/routers/[name].py` - [内容]
- [ ] `tests/test_[name].py` - [内容]

## フロントエンド実装
- [ ] `lib/types.ts` - [内容]
- [ ] `app/[path]/page.tsx` - [内容]
- [ ] `__tests__/[name].test.tsx` - [内容]

## リスク
- [リスク] → [対策]
\```

### Step 4: Validation Gate (🚨 STOP)
**ここで必ずユーザーの承認を待つ**

技術設計書ドラフトを提示し、内容を確認してもらう。
- ✅ **承認された場合**: Step 5へ進む
- ❌ **修正が必要な場合**: Step 2に戻る

### Step 5: File Creation
承認後、`[仕様書フォルダ]/[機能名]/[機能名].plan.md` を作成する。
````

---

### :pen: 例題3 - implement.prompt.md（実装ワークフロー）

実装計画に従ってコードを実装するワークフローです。

**ファイル:** `.github/prompts/implement.prompt.md`

````markdown
---
description: 実装計画に従ってコードを実装する
---

# 実装ワークフロー

## Steps

### Step 1: Context Loading
- 仕様書（`[仕様書フォルダ]/[機能名]/[機能名].spec.md`）を読み込み
- 技術計画書（`[仕様書フォルダ]/[機能名]/[機能名].plan.md`）を読み込み
- コーディング規約とテストパターンを確認

### Step 2: Implementation
技術計画書のチェックリストに従って順次実装:
- ファイル1を実装
- ファイル2を実装
- ...

### Step 3: Test Creation & Execution
各実装に対応するテストを作成・実行:
- テストを作成
- テストを実行
- カバレッジを確認

### Step 4: Structured Output
実装完了報告を作成:

\```markdown
## ✅ 実装完了報告
- [x] [ファイル名] - [実装内容]
- [x] [ファイル名] - [実装内容]

### テスト結果
- 成功: [X]件 / 失敗: [Y]件 / カバレッジ: [Z]%
\```

### Step 5: Validation Gate (🚨 STOP)
**ここで必ずユーザーの承認を待つ**

実装完了報告を提示し、以下を確認してもらう:
- [ ] すべての実装が完了している
- [ ] すべてのテストが成功している
- [ ] カバレッジが十分である

- ✅ **承認された場合**: 実装フェーズ完了
- ❌ **修正が必要な場合**: Step 2に戻る
````

---

### :pen: 例題4 - review.prompt.md（レビューワークフロー）

実装されたコードを品質観点でレビューするワークフローです。

**ファイル:** `.github/prompts/review.prompt.md`

```markdown
---
mode: fullstack-reviewer
description: 実装されたコードを品質観点でレビューし、改善提案とブロッカーを報告する
---

# コードレビューワークフロー

## Steps

### Step 1: Context Loading
以下の情報を収集:

1. **変更差分の確認**
   - `#changes` で変更ファイルを確認

2. **仕様書の確認**
   - `[仕様書フォルダ]/[機能名]/[機能名].spec.md` を読み込み

3. **テスト結果の確認**
   - `#runTests` でテスト結果を確認

4. **問題の確認**
   - `#problems` でエラーを確認

5. **プロジェクトルールの確認**
   - プロジェクト固有のルールを確認

### Step 2: Review Execution
以下の観点でレビュー:

- [ ] **仕様との整合性**: 受け入れ条件を満たしているか
- [ ] **コード品質**: コーディング規約、エラーハンドリング、セキュリティ
- [ ] **テスト**: カバレッジ80%以上、エッジケースのテスト
- [ ] **パフォーマンス**: 不要な処理がないか

### Step 3: Structured Output
レビュー結果を作成:

\```markdown
## レビュー結果

| 観点 | 結果 | コメント |
|------|------|----------|
| 仕様整合性 | ✅/⚠️/❌ | [コメント] |
| コード品質 | ✅/⚠️/❌ | [コメント] |
| テスト | ✅/⚠️/❌ | [コメント] |
| パフォーマンス | ✅/⚠️/❌ | [コメント] |

### 改善提案
- [必要な場合のみ]

### 判定: ✅承認 / ⚠️条件付き承認 / ❌却下
\```

### Step 4: Validation Gate (🚨 STOP)
**ここで必ずユーザーの承認を待つ**

レビュー結果を提示し、次のアクションを確認:

- ✅ **承認の場合**: レビュー完了
- ⚠️ **条件付き承認**: 軽微な修正を実施後に完了
- ❌ **却下の場合**: `/implement` で再実装が必要

**重要な注意事項:**
- ブロッカーが存在する場合は承認しない
- セキュリティ関連の改善提案は強く推奨
- ユーザーが承認した場合のみ完了とする
```

---

## 4. ワークフローの呼び出し方法

### 4.1 Copilot Chat から実行

Copilot Chat で `/` コマンドとして実行できます：

```text
/specify
チケット一覧ページに優先度バッジを追加

/plan
上記の仕様に基づいて実装計画を作成

/implement
計画に従って実装を開始

/review
実装内容をレビューしてください
```

### 4.2 VS Code コマンドパレットから実行

1. `Cmd/Ctrl + Shift + P` でコマンドパレットを開く
2. `Copilot: Run Prompt` を選択
3. ワークフローファイルを選択

### 4.3 ファイル内の再生ボタンから実行

`.prompt.md` ファイルを開くと、エディタ右上に **▶️ 再生ボタン** が表示されます。クリックするとワークフローが実行されます。

---

## 5. :memo: 練習

### 練習1: カスタムワークフローの作成

**タスク:** デバッグ用のワークフロー `debug.prompt.md` を作成してください。

**要件:**
- `mode: frontend-engineer` または `backend-engineer`
- エラーメッセージから原因を特定
- 修正コードを提案
- テストで検証

**ヒント:**
- Context Loading: エラーログ、スタックトレース、関連ファイルの読み込み
- Deterministic Execution: エラー分析 → 原因特定 → 修正案作成 → テスト
- Structured Output: 原因と修正案をテーブル形式で提示

### 練習2: 既存ワークフローの改良

**タスク:** `implement.prompt.md` に **アクセシビリティチェック** を追加してください。

**追加すべき項目:**
- Context Loading に「アクセシビリティガイドライン確認」を追加
- Deterministic Execution に「ステップ4.5: アクセシビリティ検証」を追加
- Structured Output に「アクセシビリティチェックリスト」を追加

### 練習3: プロジェクト固有のワークフローを設計

**タスク:** デプロイ用のワークフロー `deployment.prompt.md` を設計してください。

**含めるべき内容:**
- デプロイ前チェックリスト（テスト・ビルド・環境変数）
- デプロイ手順（ステージング → 本番）
- ロールバック手順
- デプロイ後の監視項目

---

## まとめ

* **エージェントワークフロー** は、チャットモードを呼び出す再利用可能なタスクテンプレート
* **5段階SDLC** - specify → plan → implement → review → update-context のワークフローで開発サイクルを標準化
* **4つの必須セクション** - Context Loading / Deterministic Execution / Structured Output / Validation Gate
* **2段階承認プロセス** - 各フェーズで人間の承認を得て、品質を保証
* **自動コンテキスト更新** - `/update-context` で実装内容を自動的にドキュメント化
* **呼び出し方法** - `/` コマンド / コマンドパレット / 再生ボタンの3通り
* **再利用性** - プロジェクト間で共有可能な設計パターンとして蓄積

次のセクション「⑥ 仕様駆動開発サイクルの確立」では、これら5つのワークフローを組み合わせて、実際の機能開発を通じた完全なサイクルを体験します。
