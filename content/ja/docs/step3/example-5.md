---
title: ④ エージェントワークフローの作成
categories: [AI開発ワークフロー, ワークフロー自動化]
weight: 4
tags: [prompt.md, SDLC, ワークフロー, 再利用性]
---

## 1. エージェントワークフローとは？

エージェントワークフロー（Agent Workflow）は、カスタムチャットモード（example-3.md で作成）を呼び出すための**再利用可能なタスクテンプレート**です。現実世界の「作業手順書」や「チェックリスト」のように、特定のタスクを一貫した品質で実行するための指示書として機能します。

> **ポイント**
>
> * **再利用可能なテンプレート** … 同じタスクを繰り返し実行する際の標準化
> * **チャットモードとの連携** … 特定のモード（architect / engineer / reviewer）で実行
> * **4つのセクション構造** … Context Loading / Deterministic Execution / Structured Output / Validation Gate
> * **SDLC の自動化** … specify → plan → implement → review の4段階ワークフロー

---

## 2. 4つのワークフローの設計

SDLC（Software Development Life Cycle）を4つのフェーズに分割し、それぞれにワークフローを作成します：

| ワークフロー | チャットモード | 目的 | 成果物 |
|------------|--------------|------|--------|
| **specify.prompt.md** | `architect` | 要件を技術仕様に変換 | `[仕様書フォルダ]/features/*.spec.md` |
| **plan.prompt.md** | `architect` | 実装計画の作成 | 各リポジトリの `.github/specs/*/implementation-plan.md` |
| **implement.prompt.md** | `frontend-engineer` / `backend-engineer` | コード実装 | ソースコード + テスト |
| **review.prompt.md** | `fullstack-reviewer` | 品質検証 | レビューレポート |

---

## 3. ワークフロー実装例

### :pen: 例題1 - specify.prompt.md（仕様定義ワークフロー）

ユーザーの要望や課題を、ユーザーストーリー形式の仕様書に変換し、`.spec.md` ファイルとして保存するワークフローです。**技術的な詳細は含めず**、「誰が」「何をしたいか」「なぜ必要か」に焦点を当てます。

**ファイル:** `.github/prompts/specify.prompt.md`

````markdown
---
mode: architect
description: ユーザーの要望を仕様書に変換し、.github/specs/*.spec.md ファイルとして保存する
---

# 仕様定義ワークフロー

## Context Loading Phase

仕様を定義する前に、必ず以下のドキュメントとコードベースを読み込んでください:

### 必須の事前確認

1. **プロジェクト概要**
   - `#codebase` で バックエンド、フロンエンドそれぞれの[README.md](README.md) を読み込み、プロジェクトの目的を理解

2. **既存の仕様確認**
   - `#codebase` で `[仕様書フォルダ]/features/` フォルダを検索し、既存の仕様書を確認
   - 類似機能がある場合、そのパターンを参考にする

3. **既存機能の理解**
   - `#codebase` で類似機能を検索
   - 現在のユーザー体験を把握
   - 既存のワークフローを理解

---

## Deterministic Execution

以下のステップを順番に実行してください:

### ステップ1: ユーザーストーリーの抽出

ユーザーから提供された要望を以下の観点で分析:

1. **ユーザー像** - 誰がこの機能を使うのか
2. **実現したいこと** - ユーザーは何をしたいのか
3. **目的・価値** - なぜこの機能が必要なのか
4. **成功の定義** - どうなれば成功と言えるか

### ステップ2: ユーザーストーリーの構造化

"As a [ユーザー], I want to [実現したいこと], so that [目的・価値]" 形式で整理:

例:
- **As a** サポート担当者
- **I want to** チケットの優先度を一目で確認できる
- **So that** 緊急度の高いチケットに素早く対応できる

### ステップ3: 受け入れ条件の定義

機能が完成したと判断できる具体的な条件を列挙:

- ユーザーが何を見ることができるか
- ユーザーが何をできるようになるか
- どのような操作が可能か
- どのような制約があるか

### ステップ4: ユーザーシナリオの作成

典型的な使用シナリオをストーリー形式で記述:

1. **初期状態** - ユーザーはどこから始めるか
2. **実行するアクション** - ユーザーは何をするか
3. **期待される結果** - 何が起こるべきか
4. **完了状態** - 最終的にどうなるか

### ステップ5: ビジネス価値の明確化

この機能がもたらす価値を定量的・定性的に記述:

- 作業時間の短縮
- ユーザー満足度の向上
- エラーの削減
- 業務効率の改善

### ステップ6: 仕様書のドラフト作成

上記の情報を統合し、非技術者でも理解できる仕様書のドラフトを作成する。

### ステップ7: 仕様書ファイルの作成

ユーザーの承認後、専用の仕様リポジトリに以下の構造で保存:

```
[仕様書フォルダ]/features/[機能名の英語表記].spec.md
```

例: `helpdesk-specs/features/ticket-priority-display.spec.md`

> 💡 **設計のポイント**: 仕様書は技術的な詳細を含まないため、フロントエンド・バックエンド共通の仕様書フォルダで一元管理します。実装計画は後続の `/plan` ワークフローで各リポジトリに作成されます。

---

## Structured Output Requirements

仕様書は以下のテンプレートに従って作成してください。**技術的な用語は使わず**、非技術者でも理解できる言葉で記述してください:

\```markdown
# [機能名] 仕様書

作成日: YYYY-MM-DD
最終更新: YYYY-MM-DD

## 1. 概要

[この機能が解決する課題や、実現したいことを2-3文で説明]

## 2. ユーザーストーリー

### 主要ストーリー

**As a** [ユーザーの役割]  
**I want to** [実現したいこと]  
**So that** [目的・得られる価値]

### 追加ストーリー（必要に応じて）

**As a** [ユーザーの役割]  
**I want to** [実現したいこと]  
**So that** [目的・得られる価値]

## 3. 受け入れ条件

この機能が完成したと判断できる条件:

- [ ] [ユーザーができること 1]
- [ ] [ユーザーができること 2]
- [ ] [ユーザーができること 3]
- [ ] [ユーザーが確認できること 1]
- [ ] [ユーザーが確認できること 2]

## 4. ユーザーシナリオ

### シナリオ1: [典型的な使用例]

1. **開始**: [ユーザーはどこから始めるか]
2. **アクション**: [ユーザーは何をするか]
3. **結果**: [何が表示されるか / 何が起こるか]
4. **完了**: [最終的な状態]

### シナリオ2: [別の使用例]（必要に応じて）

1. **開始**: [ユーザーはどこから始めるか]
2. **アクション**: [ユーザーは何をするか]
3. **結果**: [何が表示されるか / 何が起こるか]
4. **完了**: [最終的な状態]

## 5. UI/UX 要件

### 表示内容

- [ユーザーに見せる情報 1]
- [ユーザーに見せる情報 2]
- [ユーザーに見せる情報 3]

### 操作方法

- [ユーザーができる操作 1]
- [ユーザーができる操作 2]
- [ユーザーができる操作 3]

### 視覚的な要素

- [色分け、アイコン、レイアウトなどの視覚的な特徴]
- [優先度や状態を示す視覚的な手がかり]

## 6. ビジネス価値

この機能がもたらす価値:

| 観点 | 期待される効果 |
|------|--------------|
| **効率性** | [作業時間の短縮、手間の削減など] |
| **品質** | [エラーの削減、正確性の向上など] |
| **ユーザー満足度** | [使いやすさの向上、ストレス軽減など] |
| **ビジネスインパクト** | [売上向上、コスト削減など] |

## 7. 制約と考慮事項

### 制約

- [できないこと / やってはいけないこと 1]
- [できないこと / やってはいけないこと 2]

### 考慮事項

- [注意すべきポイント 1]
- [注意すべきポイント 2]

## 8. 成功指標

この機能が成功したと判断できる指標:

- [ ] [定量的な指標: 例「チケット対応時間が20%短縮」]
- [ ] [定性的な指標: 例「ユーザーから操作が分かりやすいとフィードバック」]
- [ ] [完了条件: 例「すべての受け入れ条件を満たしている」]

## 9. 参考情報

- [類似機能や参考になる既存機能]
- [ユーザーからのフィードバックや要望]
- [関連する仕様書へのリンク]
\```

---

## Human Validation Gate

### 🚨 ステップ6とステップ7の間で承認が必要

**仕様書のドラフトをユーザーに提示**

ステップ6で作成した仕様書をユーザーに提示し、内容の確認を求めます:

\```markdown
## 📋 作成した仕様書（ドラフト）

[上記のテンプレートに従った仕様書の内容]

---

🚨 **STOP - 承認してください**

この仕様書の内容を確認してください。

✅ **内容に問題がなければ**: **"go"** または **"承認"** と入力
❌ **修正が必要な場合**: 具体的な修正内容を指示してください

承認後、ステップ7で仕様書ファイルを仕様書リポジトリに保存します。
\```

**ユーザーが承認した後の動作**

ユーザーが "go" または "承認" と入力したら、ステップ7を自動実行:

1. **ステップ7を実行:**
   `[仕様書フォルダ]/features/[機能名の英語表記].spec.md` を作成
   
   実行結果を報告:
   ```
   ✅ ステップ7完了: 仕様書を作成しました
   → [仕様書フォルダ]/features/[機能名の英語表記].spec.md
   ```

2. **完了メッセージを表示:**

\```markdown
✅ 仕様定義ワークフローが完了しました

📄 **作成内容:**
- 仕様書: `[仕様書フォルダ]/features/[機能名の英語表記].spec.md`

**次のステップ:**
- フロントエンド実装が必要な場合: フロントエンドリポジトリで `/plan` を実行
- バックエンド実装が必要な場合: バックエンドリポジトリで `/plan` を実行
- 両方必要な場合: それぞれのリポジトリで `/plan` を実行

**実装計画の参照:**
各リポジトリで `/plan` を実行する際、以下のように仕様書を参照します:
```
#file:../../[仕様書フォルダ]/features/[機能名の英語表記].spec.md
```
\```

### ⚠️ 重要な注意事項

- **ステップ7は承認後に実行**: ユーザーの承認なしに仕様書を保存しないでください
- **修正が必要な場合**: 仕様書を修正してステップ6からやり直し、再度承認を求めてください
- **仕様書の配置**: 技術的な詳細を含まない仕様書は専用の仕様書フォルダで一元管理
- **実装計画は別**: 各リポジトリでの実装計画は `/plan` ワークフローで作成されます
````

### :robot: 使用例

**ユーザーの入力:**
```text
/specify

チケット対応の担当者が、緊急度の高いチケットを
素早く見つけられるようにしたい。
```

**期待される動作:**

1. **Context Loading 完了報告**
   ```
   ✅ Context Loading 完了:
   - プロジェクト概要確認: チケット管理システム
   - 既存機能確認: チケット一覧ページが存在
   - 類似機能確認: ステータス表示機能あり
   ```

2. **仕様書の作成と提示**

```markdown
# チケット優先度表示機能 仕様書

## 1. 概要

サポート担当者が緊急度の高いチケットを一目で識別できるようにする機能。
視覚的な優先度表示により、対応の優先順位付けを支援し、重要なチケットへの
迅速な対応を可能にする。

## 2. ユーザーストーリー

### 主要ストーリー

**As a** サポート担当者  
**I want to** チケットの優先度を一目で確認できる  
**So that** 緊急度の高いチケットに素早く対応できる

## 3. 受け入れ条件

- [ ] チケット一覧で各チケットの優先度が表示されている
- [ ] 優先度レベル（緊急/高/中/低）が視覚的に区別できる
- [ ] 優先度の高いチケットが目立つ表示になっている
- [ ] 既存のチケット一覧の使い勝手を損なわない

## 4. ユーザーシナリオ

### シナリオ1: 朝の業務開始時

1. **開始**: サポート担当者がチケット一覧ページを開く
2. **確認**: 各チケットに優先度が色分けして表示されている
3. **判断**: 赤色で表示されている「緊急」チケットを発見
4. **完了**: 緊急チケットから順に対応を開始

## 5. UI/UX 要件

### 表示内容

- 各チケットの優先度レベル（緊急/高/中/低）
- 優先度を示すラベルまたはバッジ

### 視覚的な要素

- 緊急: 赤色で目立つ表示
- 高: 標準的な強調表示
- 中: やや控えめな表示
- 低: 最も控えめな表示

## 6. ビジネス価値

| 観点 | 期待される効果 |
|------|--------------|
| **効率性** | チケット確認時間を30%短縮 |
| **品質** | 重要チケットの見落としゼロ |
| **ユーザー満足度** | 対応優先度の判断が容易になる |
| **ビジネスインパクト** | 顧客満足度の向上、SLA達成率向上 |

## 8. 成功指標

- [ ] 緊急チケットへの平均対応時間が20%短縮
- [ ] サポート担当者から「優先度が分かりやすい」とフィードバック
- [ ] すべての受け入れ条件を満たしている
```

3. **🚨 ステップ6完了 - 承認待ち**
   ```
   🚨 STOP - 承認してください
   
   この仕様書の内容を確認してください。
   問題がなければ "go" と入力してください。
   
   承認後、ステップ7で仕様書リポジトリに仕様書を保存します。
   ```

4. **ユーザーが "go" と入力**

5. **ステップ7を自動実行**
   ```
   ✅ ステップ7完了: 仕様書を作成しました
   → [仕様書フォルダ]/features/ticket-priority-display.spec.md
   
   次のステップ:
   - フロントエンド実装: フロントエンドリポジトリで `/plan` を実行
   - バックエンド実装: バックエンドリポジトリで `/plan` を実行
   ```

---

### :pen: 例題2 - plan.prompt.md（計画策定ワークフロー）

`.spec.md` ファイルを読み込み、技術設計＆タスク書を作成し、各リポジトリに配置するワークフローです。

**ファイル:** `.github/prompts/plan.prompt.md`

````markdown
---
mode: architect
description: .spec.md ファイルを読み込み、フロントエンドとバックエンド両方の実装計画をチェックリスト形式で作成する
---

# 実装計画ワークフロー

## Context Loading Phase

実装計画を作成する前に、必ず以下の情報を収集してください:

### 必須の事前確認

1. **仕様書の読み込み**
   - `[仕様書フォルダ]/features/[機能名].spec.md` で仕様書を読み込み
   - または `#codebase` で `[仕様書フォルダ]/features/` を検索
   - 仕様書の全内容を読み込み、理解

2. **プロジェクト構造の把握**
   - フロントエンドのディレクトリ構造を確認
   - バックエンドのディレクトリ構造を確認
   - [API仕様書](../../docs/context/api-specification.context.md) を参照し、API連携の必要性を確認
   - [データモデル](../../docs/context/database-schema.context.md) を参照し、データ構造を理解
   - どこに何を配置すべきかを理解

3. **依存関係の確認**
   - 変更が必要なファイルのリストアップ
   - 各ファイル間の依存関係を把握
   - 実装順序の決定

6. **既存実装パターンの調査**
   - `#codebase` で類似機能の実装を検索
   - 既存のテストパターンを確認
   - プロジェクトの実装スタイルに合わせる

---

## Deterministic Execution

以下のステップを順番に実行してください:

### ステップ1: フロントエンドとバックエンドの責務を分解

仕様書から、**フロントエンドとバックエンド両方で実装すべき内容**を抽出:

**フロントエンド実装項目:**
1. **型定義** - TypeScript の型・インターフェースの追加/変更
2. **API クライアント** - バックエンドAPIとの連携コード
3. **UI コンポーネント** - 画面コンポーネントの追加/変更
4. **状態管理** - Context API / Zustand などの状態管理
5. **スタイリング** - Tailwind CSS / CSS Modules の追加/変更
6. **バリデーション** - フォームバリデーション、入力検証
7. **テスト** - 単体テスト・E2E テストの作成

**バックエンド実装項目:**
1. **データモデル** - SQLAlchemy モデルの追加/変更
2. **スキーマ定義** - Pydantic スキーマ（リクエスト/レスポンス）
3. **ビジネスロジック** - サービス層の実装
4. **API エンドポイント** - FastAPI ルーターの追加/変更
5. **データベースマイグレーション** - Alembic マイグレーションの作成
6. **認証・認可** - アクセス制御の実装
7. **テスト** - pytest による単体テスト・統合テストの作成

⚠️ **重要**:
- 両方のリポジトリで実装が必要な機能の場合は、フロントエンドとバックエンドの両方の責務を明確にしてください
- 片方のみの実装で済む場合は、該当する方のみを詳細に記述してください

### ステップ2: 技術設計の作成（フロントエンドとバックエンド）

**フロントエンドとバックエンド、それぞれの**技術スタックに基づいて設計を行う:

**フロントエンド設計:**
1. **アーキテクチャ設計** - コンポーネント構成、状態管理の配置
2. **データフロー設計** - UIからAPIクライアント、状態管理の流れ
3. **エラーハンドリング設計** - ユーザーへのエラー表示方法
4. **パフォーマンス考慮** - レンダリング最適化、遅延読み込み

**バックエンド設計:**
1. **アーキテクチャ設計** - レイヤー構成（モデル、スキーマ、サービス、ルーター）
2. **データフロー設計** - リクエストからレスポンスまでの処理フロー
3. **エラーハンドリング設計** - 例外処理、HTTPステータスコード
4. **パフォーマンス考慮** - クエリ最適化、キャッシング戦略

### ステップ3: 実装順序の決定（全体とそれぞれの内部順序）

**全体の実装順序:**
```
バックエンド → フロントエンド
```
理由: APIエンドポイントが確定しないとフロントエンドの実装が困難

**バックエンドの実装順序:**
```
データモデル → スキーマ定義 → ビジネスロジック → API エンドポイント → テスト
```

**フロントエンドの実装順序:**
```
型定義 → API クライアント → UI コンポーネント → 状態管理 → テスト
```

⚠️ **並行開発の場合**: API仕様が事前に確定している場合は、フロントエンドとバックエンドを並行開発可能

### ステップ4: リスクの評価

実装レベルでのリスクを評価:

- 技術的な複雑さ（難易度）
- 既存コードへの影響範囲
- テストの難しさ
- パフォーマンスへの影響
- セキュリティ上の考慮事項

### ステップ5: 所要時間の見積もり

各タスクの所要時間を見積もり、合計所要時間を算出

### ステップ6: 技術設計＆タスク書ファイルの作成（両方）

ユーザーの承認後、以下の**両方の**ファイルを作成:

**1. バックエンド技術設計＆タスク書:**
```
[バックエンドのフォルダ]/.github/specs/[機能名の英語表記]/[機能名の英語表記]-plan.md
```
例: `PoC-GitHubCopilotApp2-Backend/.github/specs/ticket-priority-display/ticket-priority-display-plan.md`

**2. フロントエンド技術設計＆タスク書:**
```
[フロントエンドのフォルダ]/.github/specs/[機能名の英語表記]/[機能名の英語表記]-plan.md
```
例: `PoC-GitHubCopilotApp2-Frontend/.github/specs/ticket-priority-display/ticket-priority-display-plan.md`

⚠️ **注意事項:**
- 仕様によってはフロントエンドのみ、またはバックエンドのみの実装になる場合があります
- その場合は該当する方のみのファイルを作成してください
- 両方必要な場合は、必ず両方のファイルを作成してください

---

## Structured Output Requirements

技術設計＆タスク書は以下のテンプレートに従って作成してください:

\```markdown
# [機能名] 技術設計＆タスク書 - [フロントエンド|バックエンド]

作成日: YYYY-MM-DD
仕様書: `[仕様書フォルダ]/features/[機能名].spec.md`

## 1. 技術設計

### 1.1 アーキテクチャ概要

[この機能を実装するためのアーキテクチャ設計を記述]

**レイヤー構成:**
- [レイヤー1]: [役割]
- [レイヤー2]: [役割]
- [レイヤー3]: [役割]

### 1.2 データフロー

\```
[ユーザー操作] → [UIコンポーネント] → [API クライアント] → [バックエンド]
                                                                    ↓
[UIに反映] ← [状態管理] ← [レスポンス処理] ← [API レスポンス]
\```

### 1.3 使用する技術・ライブラリ

| 技術/ライブラリ | 用途 | 理由 |
|----------------|------|------|
| [技術1] | [用途] | [選定理由] |
| [技術2] | [用途] | [選定理由] |

### 1.4 エラーハンドリング設計

- **クライアントエラー（400系）**: [処理方法]
- **サーバーエラー（500系）**: [処理方法]
- **ネットワークエラー**: [処理方法]
- **バリデーションエラー**: [処理方法]

### 1.5 パフォーマンス考慮

- [最適化ポイント1]
- [最適化ポイント2]
- [最適化ポイント3]

---

## 2. 実装タスク一覧

### 変更ファイル

**フロントエンドの場合:**
- [ ] `lib/types.ts` - [変更内容の1行説明]
- [ ] `lib/api-client.ts` - [変更内容の1行説明]
- [ ] `app/[path]/page.tsx` - [変更内容の1行説明]
- [ ] `components/[name].tsx` - [変更内容の1行説明]
- [ ] `__tests__/[name].test.tsx` - [変更内容の1行説明]

**バックエンドの場合:**
- [ ] `app/models/[name].py` - [変更内容の1行説明]
- [ ] `app/schemas/[name].py` - [変更内容の1行説明]
- [ ] `app/services/[name].py` - [変更内容の1行説明]
- [ ] `app/routers/[name].py` - [変更内容の1行説明]
- [ ] `alembic/versions/[timestamp]_[name].py` - [変更内容の1行説明]
- [ ] `tests/test_[name].py` - [変更内容の1行説明]

---

## 3. 詳細タスク

### タスク1: [タスク名]
---

## Human Validation Gate

### 🚨 ステップ6の前で承認が必要

**フロントエンドとバックエンド両方の技術設計＆タスク書の概要をユーザーに提示**

ステップ5までで作成した**両方の**技術設計＆タスク書について、詳細ではなく**概要**を提示し、内容の確認を求めます:

\```markdown
## 📋 技術設計＆タスク書の概要（ドラフト）

### 🔹 バックエンド技術設計＆タスク書の概要

**実装範囲:**
- データモデル: [追加/変更するモデルのリスト]
- API エンドポイント: [追加/変更するエンドポイントのリスト]
- 主要な変更ファイル: [ファイル数]個

**主要な技術選定:**
- [技術1]: [用途]
- [技術2]: [用途]

**想定タスク数:** [X]個
**見積もり所要時間:** 約[Y]分

**主なリスク:**
- [リスク1]
- [リスク2]

---

### 🔹 フロントエンド技術設計＆タスク書の概要

**実装範囲:**
- 型定義: [追加/変更する型のリスト]
- UI コンポーネント: [追加/変更するコンポーネントのリスト]
- 主要な変更ファイル: [ファイル数]個

**主要な技術選定:**
- [技術1]: [用途]
- [技術2]: [用途]

**想定タスク数:** [X]個
**見積もり所要時間:** 約[Y]分

**主なリスク:**
- [リスク1]
- [リスク2]

---

🚨 **STOP - 承認が必要です**

上記の**フロントエンドとバックエンド両方の**技術設計＆タスク書の概要を確認してください。

✅ **内容に問題がなければ**: **"go"** または **"承認"** と入力
❌ **修正が必要な場合**: 具体的な修正内容を指示してください（フロントエンド/バックエンドを明示）
📄 **詳細を確認したい場合**: 「詳細を表示」と入力すると、該当部分の詳細を表示します

承認後、ステップ6で以下のファイルを作成します:
- `[バックエンドのフォルダ]/.github/specs/[機能名]/[機能名]-plan.md`
- `[フロントエンドのフォルダ]/.github/specs/[機能名]/[機能名]-plan.md`
\```

**ユーザーが承認した後の動作**

ユーザーが "go" または "承認" と入力したら、ステップ6を自動実行:

1. **ステップ6を実行:**
   以下の**両方の**ファイルを作成:
   - `[バックエンドのフォルダ]/.github/specs/[機能名の英語表記]/[機能名の英語表記]-plan.md`
   - `[フロントエンドのフォルダ]/.github/specs/[機能名の英語表記]/[機能名の英語表記]-plan.md`

   実行結果を報告:
   ```
   ✅ ステップ6完了: 技術設計＆タスク書を作成しました
   → バックエンド: [バックエンドのフォルダ]/.github/specs/[機能名の英語表記]/[機能名の英語表記]-plan.md
   → フロントエンド: [フロントエンドのフォルダ]/.github/specs/[機能名の英語表記]/[機能名の英語表記]-plan.md
   ```

2. **完了メッセージを表示:**

```markdown
✅ 実装計画ワークフローが完了しました

📄 **作成内容:**
- バックエンド技術設計＆タスク書: `[バックエンドのフォルダ]/.github/specs/[機能名の英語表記]/[機能名の英語表記]-plan.md`
- フロントエンド技術設計＆タスク書: `[フロントエンドのフォルダ]/.github/specs/[機能名の英語表記]/[機能名の英語表記]-plan.md`

**次のステップ:**
- `/implement` で実装を開始
- 技術設計＆タスク書を参照しながら、順次タスクを実行してください
- 実装順序: バックエンド → フロントエンド（または並行開発）

**実装時の参照:**
実装ワークフローでは、以下のファイルを参照します:
- 仕様書: `[仕様書フォルダ]/features/[機能名].spec.md`
- バックエンド技術設計: `[バックエンドのフォルダ]/.github/specs/[機能名]/[機能名]-plan.md`
- フロントエンド技術設計: `[フロントエンドのフォルダ]/.github/specs/[機能名]/[機能名]-plan.md`
\```

### ⚠️ 重要な注意事項

- **ステップ6は承認後に実行**: ユーザーの承認なしにファイルを作成しないでください
- **修正が必要な場合**: 技術設計＆タスク書を修正して、再度承認を求めてください
- **両方のファイルを作成**: フロントエンドとバックエンド両方の実装が必要な場合、必ず両方のファイルを作成してください
- **ファイルの配置**: 各リポジトリの `.github/specs/[機能名]/` ディレクトリに配置
  - バックエンド: `[バックエンドのフォルダ]/.github/specs/[機能名]/[機能名]-plan.md`
  - フロントエンド: `[フロントエンドのフォルダ]/.github/specs/[機能名]/[機能名]-plan.md`
- **実装計画は別管理**: 仕様書（非技術）は共有、技術設計＆タスク書（技術的）は各リポジトリで独立管理
- **片方のみの実装**: 仕様によっては片方のみの実装で済む場合があります。その場合は該当する方のみのファイルを作成
```

### 4.2 統合テスト（該当する場合）

- [ ] [統合テストケース1]
- [ ] [統合テストケース2]

### 4.3 E2Eテスト（該当する場合）

- [ ] [E2Eテストシナリオ1]
- [ ] [E2Eテストシナリオ2]

---

## 5. リスク評価

### セキュリティリスク

- [ ] **リスク内容**: [詳細]
  - **対策**: [具体的な対策]

### パフォーマンスリスク

- [ ] **リスク内容**: [詳細]
  - **対策**: [具体的な対策]

### 互換性リスク

- [ ] **リスク内容**: [詳細]
  - **対策**: [具体的な対策]

---

## 6. 実装順序

1. **[タスク名]** (見積もり: [X]分)
   - 理由: [なぜこれが最初か]

2. **[タスク名]** (見積もり: [Y]分)
   - 理由: [依存関係]

3. **[タスク名]** (見積もり: [Z]分)
   - 理由: [依存関係]

[以降、必要なタスクを追加]

**合計所要時間:** 約 [X]分

---

## 7. 参考情報

- **仕様書**: `[仕様書フォルダ]/features/[機能名].spec.md`
- **API仕様**: [関連するAPI仕様へのリンク]
- **関連コード**: [参考になる既存実装へのリンク]
- **設計ドキュメント**: [関連する設計ドキュメントへのリンク]
\```

---

## 実装開始前の最終確認

### ⚠️ 重要な注意事項

- **ユーザーの承認なしに実装を開始しないでください**
- **修正指示があった場合は、計画を修正して再度承認を求めてください**
- **両方のファイルが作成されたことを確認**: 実装開始前に、フロントエンドとバックエンド両方の技術設計＆タスク書が作成されていることを確認してください
- **実装順序の遵守**: 基本的にバックエンド → フロントエンドの順で実装します（API仕様が確定している場合は並行開発可能）

### 次のステップ

ユーザーが承認し、両方のファイルが作成されたら、以下を表示:

\```markdown
✅ 承認ありがとうございます。実装計画が確定しました。

📄 **作成された技術設計＆タスク書:**
- バックエンド: `[バックエンドのフォルダ]/.github/specs/[機能名]/[機能名]-plan.md`
- フロントエンド: `[フロントエンドのフォルダ]/.github/specs/[機能名]/[機能名]-plan.md`

**次のステップ:**
1. `/implement` で実装を開始
2. まずバックエンドの実装から開始することを推奨
3. バックエンドAPI完成後、フロントエンドの実装に進む

**実装時の参考:**
- 各技術設計＆タスク書のチェックリストに従って順次実装
- テストも並行して作成
- 不明点があれば仕様書を参照
```

### 4.2 統合テスト（該当する場合）

- [ ] [統合テストケース1]
- [ ] [統合テストケース2]

### 4.3 E2Eテスト（該当する場合）

- [ ] [E2Eテストシナリオ1]
- [ ] [E2Eテストシナリオ2]

---

## 5. リスク評価

### セキュリティリスク

- [ ] **リスク内容**: [詳細]
  - **対策**: [具体的な対策]

### パフォーマンスリスク

- [ ] **リスク内容**: [詳細]
  - **対策**: [具体的な対策]

### 互換性リスク

- [ ] **リスク内容**: [詳細]
  - **対策**: [具体的な対策]

---

## 6. 実装順序

1. **[タスク名]** (見積もり: [X]分)
   - 理由: [なぜこれが最初か]

2. **[タスク名]** (見積もり: [Y]分)
   - 理由: [依存関係]

3. **[タスク名]** (見積もり: [Z]分)
   - 理由: [依存関係]

[以降、必要なタスクを追加]

**合計所要時間:** 約 [X]分

---

## 7. 参考情報

- **仕様書**: `[仕様書フォルダ]/features/[機能名].spec.md`
- **API仕様**: [関連するAPI仕様へのリンク]
- **関連コード**: [参考になる既存実装へのリンク]
- **設計ドキュメント**: [関連する設計ドキュメントへのリンク]
\```

---

## Human Validation Gate

### 🚨 STOP - 2段階承認プロセス

**段階1: 実装計画の提示**

作成した実装計画をユーザーに提示し、内容の確認を求めます:

\```markdown
## 📋 実装計画

[上記のチェックリスト形式の計画]

---

🚨 **STOP - 承認が必要です**

この実装計画の内容を確認してください。

- 内容に問題がなければ **"go"** または **"承認"** と入力してください。
- 修正が必要な場合は、具体的な修正内容を指示してください。

承認後、`/implement` ワークフローで実装を開始できます。
\```

**段階2: 次のステップへの誘導**

ユーザーが "go" または "承認" と入力したら、以下を表示:

\```markdown
✅ 承認ありがとうございます。実装計画が確定しました。

次のステップ:
- `/implement` で実装を開始
- または、計画を `.spec.md` ファイルに追記して記録
\```

### ⚠️ 重要な注意事項

- ユーザーの承認なしに実装を開始しないでください
- 修正指示があった場合は、計画を修正して再度承認を求めてください
- 計画が承認されたら、`.spec.md` ファイルに追記することを推奨（任意）
````

---

### :pen: 例題3 - implement.prompt.md（実装ワークフロー）

実装計画に従ってコードを実装するワークフローです。

**ファイル:** `.github/prompts/implement.prompt.md`

````markdown
---
description: 仕様書と技術計画書を読み込み、実装計画に従ってコードを実装し、テストを作成・実行する（フロントエンド/バックエンド共通）
---

# 実装ワークフロー（フロントエンド/バックエンド共通）

## Context Loading Phase

実装を開始する前に、必ず以下の情報を収集してください:

### 必須の事前確認

1. **仕様書の読み込み**
   - `[仕様書フォルダ]/features/[機能名].spec.md` で仕様書を読み込み
   - 機能の要件と仕様を理解
   - 実装すべき内容を把握

2. **技術計画書の読み込み**

   **フロントエンドの場合:**
   - `[フロントエンドのフォルダ]/.github/specs/[機能名]/[機能名]-plan.md` を読み込み
   - バックエンドAPI仕様も確認: `[バックエンドのフォルダ]/.github/specs/[機能名]/[機能名]-plan.md`

   **バックエンドの場合:**
   - `[バックエンドのフォルダ]/.github/specs/[機能名]/[機能名]-plan.md` を読み込み
   - フロントエンド要件も確認: `[フロントエンドのフォルダ]/.github/specs/[機能名]/[機能名]-plan.md`（必要に応じて）

   - 技術設計の内容を理解
   - 実装タスク一覧を確認
   - タスクの優先順位と依存関係を理解

3. **プロジェクト構造の確認**
   - 変更対象ファイルの現在の状態を確認
   - ディレクトリ構造を把握
   - 既存のインポート文・依存関係を確認

4. **コーディング規約の確認**
   - `.github/copilot-instructions.md` を読み込み
   - プロジェクト固有のルールを遵守
   - 既存コードのスタイルに合わせる

5. **テストパターンの確認**

   **フロントエンドの場合:**
   - `__tests__/` ディレクトリを検索
   - 使用しているテストライブラリ（Vitest / React Testing Library）を確認

   **バックエンドの場合:**
   - `tests/` ディレクトリを検索
   - 使用しているテストライブラリ（pytest）を確認

   - 既存のテストコードのパターンを理解

⚠️ **重要**:
- 仕様書と技術計画書を必ず読み込んでから実装を開始してください
- フロントエンド実装時、バックエンドAPIが未実装の場合はモックデータで開発を進めてください
- バックエンド実装時、データベースマイグレーションの必要性を確認してください

---

## Deterministic Execution

技術計画書の「実装順序」セクションに従って、以下のステップを**必ず順番に**実行してください:

### ステップ1: 実装準備

1. **技術計画書のタスク一覧を確認**
   - 実装すべきファイルのリストを把握
   - 各ファイルの変更内容を理解
   - 依存関係を確認

2. **既存コードの確認**
   - 変更対象ファイルを読み込み
   - 既存の実装パターンを理解
   - インポート文や依存関係を確認

---

## フロントエンド実装ステップ

### ステップ2-F: 型定義の追加/変更

**対象ファイル:** `lib/types.ts`

1. 必要な型・インターフェースを追加
2. バックエンドのレスポンス型と整合性を確認
3. 既存の型との整合性を確認
4. エクスポートの追加

### ステップ3-F: API クライアントの実装/変更

**対象ファイル:** `lib/api-client.ts`

1. 必要なAPIエンドポイントを追加
2. リクエスト/レスポンスの型を適用
3. エラーハンドリングを実装
4. バックエンドAPIが未実装の場合はモックデータを使用

### ステップ4-F: UI コンポーネントの実装

**対象ファイル:** `app/[path]/page.tsx` または `components/[name].tsx`

1. 必要なインポートを追加
2. 状態管理（useState, useContext等）の実装
3. APIクライアントの呼び出し
4. UIの実装（仕様書のUI仕様に従う）
5. エラーハンドリングとローディング状態の実装

### ステップ5-F: スタイリングの実装

1. Tailwind CSS クラスの適用
2. 仕様書のUI仕様に従ったスタイリング
3. レスポンシブデザインの実装
4. アクセシビリティ属性の追加（aria-label等）

### ステップ6-F: テストの作成

**対象ファイル:** `__tests__/[name].test.tsx`

1. テストファイルの作成
2. テストケースの実装:
   - 正常系のテスト（技術計画書に記載）
   - 異常系のテスト（エラーハンドリング）
   - エッジケースのテスト
3. モックの設定（API呼び出し、Context等）

### ステップ7-F: テストの実行と修正

1. Vitestを使用してテストを実行
2. 失敗したテストがある場合は原因を分析して修正
3. すべてのテストが成功するまで繰り返す
4. カバレッジを確認

---

## バックエンド実装ステップ

### ステップ2-B: データモデルの追加/変更

**対象ファイル:** `app/models/[name].py`

1. SQLAlchemyモデルクラスの定義
2. テーブル構造の設計（カラム、制約、リレーション）
3. 既存モデルとの関連性を確認
4. インデックスの追加

### ステップ3-B: スキーマ定義の追加/変更

**対象ファイル:** `app/schemas/[name].py`

1. Pydanticスキーマの定義
2. リクエストスキーマ（バリデーション）
3. レスポンススキーマ
4. 既存スキーマとの整合性を確認

### ステップ4-B: ビジネスロジックの実装

**対象ファイル:** `app/services/[name].py`

1. サービス層の関数を実装
2. データベース操作（CRUD）
3. ビジネスルールの実装
4. エラーハンドリング

### ステップ5-B: API エンドポイントの実装

**対象ファイル:** `app/routers/[name].py`

1. FastAPI ルーターの定義
2. エンドポイントの実装（GET, POST, PUT, DELETE等）
3. 認証・認可の実装
4. レスポンスの返却

### ステップ6-B: データベースマイグレーションの作成

**対象ファイル:** `alembic/versions/[timestamp]_[name].py`

1. Alembicマイグレーションファイルの生成
2. マイグレーション内容の確認
3. マイグレーションの適用

### ステップ7-B: テストの作成

**対象ファイル:** `tests/test_[name].py`

1. テストファイルの作成
2. テストケースの実装:
   - 正常系のテスト
   - 異常系のテスト（エラーハンドリング）
   - エッジケースのテスト
3. テストデータの準備（フィクスチャ）

### ステップ8-B: テストの実行と修正

1. pytestを使用してテストを実行
2. 失敗したテストがある場合は原因を分析して修正
3. すべてのテストが成功するまで繰り返す
4. カバレッジを確認

---

## Structured Output Requirements

実装完了後、以下の形式で報告してください（フロントエンド/バックエンドに応じて適切な方を使用）:

### フロントエンド実装完了報告

\```markdown
## ✅ フロントエンド実装完了報告

### 📄 参照ドキュメント

- **仕様書**: `[仕様書フォルダ]/features/[機能名].spec.md`
- **技術計画書**: `[フロントエンドのフォルダ]/.github/specs/[機能名]/[機能名]-plan.md`

### 📝 実装したファイル（技術計画書のタスク一覧に対応）

- [x] `lib/types.ts` - [実装内容の1行説明]
- [x] `lib/api-client.ts` - [実装内容の1行説明]
- [x] `app/[path]/page.tsx` - [実装内容の1行説明]
- [x] `components/[name].tsx` - [実装内容の1行説明]
- [x] `__tests__/[name].test.tsx` - [実装内容の1行説明]

### 🧪 テスト結果

- **成功**: [X] 件
- **失敗**: [Y] 件
- **カバレッジ**: [Z]%
- **テストフレームワーク**: Vitest + React Testing Library

### 📋 技術計画書との対応

#### 実装順序の遵守
- [x] ステップ2-F: 型定義
- [x] ステップ3-F: API クライアント
- [x] ステップ4-F: UI コンポーネント
- [x] ステップ5-F: スタイリング
- [x] ステップ6-F: テスト

#### リスク対策の実施状況
- [x] [リスク1]: [対策内容]
- [x] [リスク2]: [対策内容]

### 📊 変更の詳細（抜粋）

#### 1. 型定義（`lib/types.ts`）

\```typescript
// バックエンドAPIのレスポンス型に対応
[追加した型定義のコード]
\```

#### 2. API クライアント（`lib/api-client.ts`）

\```typescript
[追加したAPIクライアント関数のコード]
\```

#### 3. UI コンポーネント（主要部分）

\```tsx
// 仕様書のUI仕様に対応
[主要な実装コードの抜粋]
\```

### 🔄 バックエンドとの連携状況

- **バックエンドAPI実装状況**: [実装済み / 並行開発中 / 未実装（モック使用）]
- **API疎通確認**: [完了 / 未実施]

### ⚠️ 既知の問題・制約事項

（問題がない場合は「なし」と記載）
\```

---

### バックエンド実装完了報告

\```markdown
## ✅ バックエンド実装完了報告

### 📄 参照ドキュメント

- **仕様書**: `[仕様書フォルダ]/features/[機能名].spec.md`
- **技術計画書**: `[バックエンドのフォルダ]/.github/specs/[機能名]/[機能名]-plan.md`

### 📝 実装したファイル（技術計画書のタスク一覧に対応）

- [x] `app/models/[name].py` - [実装内容の1行説明]
- [x] `app/schemas/[name].py` - [実装内容の1行説明]
- [x] `app/services/[name].py` - [実装内容の1行説明]
- [x] `app/routers/[name].py` - [実装内容の1行説明]
- [x] `alembic/versions/[timestamp]_[name].py` - [実装内容の1行説明]
- [x] `tests/test_[name].py` - [実装内容の1行説明]

### 🧪 テスト結果

- **成功**: [X] 件
- **失敗**: [Y] 件
- **カバレッジ**: [Z]%
- **テストフレームワーク**: pytest

### 📋 技術計画書との対応

#### 実装順序の遵守
- [x] ステップ2-B: データモデル
- [x] ステップ3-B: スキーマ定義
- [x] ステップ4-B: ビジネスロジック
- [x] ステップ5-B: API エンドポイント
- [x] ステップ6-B: データベースマイグレーション
- [x] ステップ7-B: テスト

#### リスク対策の実施状況
- [x] [リスク1]: [対策内容]
- [x] [リスク2]: [対策内容]

### 📊 変更の詳細（抜粋）

#### 1. データモデル（`app/models/[name].py`）

\```python
# SQLAlchemyモデル定義
[追加したモデルのコード]
\```

#### 2. スキーマ定義（`app/schemas/[name].py`）

\```python
# Pydanticスキーマ定義
[追加したスキーマのコード]
\```

#### 3. API エンドポイント（`app/routers/[name].py`）

\```python
# FastAPIルーター定義
[追加したエンドポイントのコード]
\```

### 🗄️ データベース関連

- **マイグレーション**: [作成済み / 適用済み]
- **マイグレーションファイル**: `alembic/versions/[timestamp]_[name].py`
- **影響範囲**: [新規テーブル / 既存テーブル変更]

### 🔄 フロントエンドとの連携

- **フロントエンド実装状況**: [実装済み / 並行開発中 / 未実装]
- **API仕様の共有**: [完了 / 未実施]

### ⚠️ 既知の問題・制約事項

（問題がない場合は「なし」と記載）
\```

#### 2. API クライアント（`lib/api-client.ts`）

\```typescript
// 技術計画書のエンドポイント一覧に対応
[追加したAPIクライアント関数のコード]
\```

#### 3. UI コンポーネント（主要部分）

\```tsx
// 仕様書のUI仕様に対応
[主要な実装コードの抜粋]
\```

#### 4. テスト（主要テストケース）

\```typescript
// 技術計画書のテストケースに対応
[主要なテストケースの抜粋]
\```

### ⚠️ 既知の問題・制約事項

- [ ] 問題1: [説明] - [対応予定]
- [ ] 制約1: [説明] - [理由]

（問題がない場合は「なし」と記載）

### 🔄 バックエンドとの連携状況

- **バックエンドAPI実装状況**: [実装済み / 並行開発中 / 未実装（モック使用）]
- **API疎通確認**: [完了 / 未実施]
- **統合テスト**: [実施済み / 予定]
\```

---

## Human Validation Gate

### 🚨 STOP - 実装内容の確認

**実装完了報告をユーザーに提示**

すべての実装とテストが完了したら、フロントエンド/バックエンドに応じた形式で実装完了報告を提示します:

\```markdown
## ✅ [フロントエンド|バックエンド]実装完了報告

[上記の形式に従った詳細な報告]

---

🚨 **STOP - 確認が必要です**

実装内容を確認してください。

✅ **内容に問題がなければ**: **"go"** または **"承認"** と入力
❌ **修正が必要な場合**: 具体的な修正内容を指示してください（ファイル名を明示）
📄 **詳細を確認したい場合**: 「[ファイル名]の詳細を表示」と入力

**確認ポイント:**
- [ ] 技術計画書のすべてのタスクが完了している
- [ ] すべてのテストが成功している
- [ ] 仕様書の要件を満たしている
- [ ] 連携先（フロントエンド/バックエンド）との整合性が取れている

承認後の次のステップ:
- **フロントエンド実装の場合**:
  - バックエンド実装が完了している場合: 統合テスト・E2Eテスト
  - バックエンド実装が未完了の場合: バックエンド実装の完了を待つ
- **バックエンド実装の場合**:
  - フロントエンド実装が完了している場合: 統合テスト
  - フロントエンド実装が未完了の場合: フロントエンド実装を開始
\```

### ⚠️ 重要な注意事項

- **すべてのテストが成功するまで完了報告を出さないでください**
- **技術計画書のタスク一覧がすべて完了していることを確認してください**
- **テストが失敗している場合は、まず修正してください**
- **ユーザーの承認なしに次のフェーズに進まないでください**
- **フロントエンド実装時、バックエンドAPIが未実装の場合はモックデータで開発していることを明記してください**
- **バックエンド実装時、データベースマイグレーションを適用したことを確認してください**

### 実装完了後の推奨アクション

ユーザーが承認したら、以下を表示:

**フロントエンド実装完了の場合:**
\```markdown
✅ 承認ありがとうございます。フロントエンド実装が完了しました。

📄 **実装完了:**
- フロントエンド: すべてのタスク完了
- テスト: すべて成功
- 技術計画書: `[フロントエンドのフォルダ]/.github/specs/[機能名]/[機能名]-plan.md`

**次のステップ:**
1. バックエンド実装状況を確認
2. 両方完了している場合: 統合テスト・E2Eテストの実施
3. 必要に応じてコードレビューの実施

**バックエンドが未実装の場合:**
- バックエンド実装を開始してください
\```

**バックエンド実装完了の場合:**
\```markdown
✅ 承認ありがとうございます。バックエンド実装が完了しました。

📄 **実装完了:**
- バックエンド: すべてのタスク完了
- テスト: すべて成功
- データベースマイグレーション: 適用済み
- 技術計画書: `[バックエンドのフォルダ]/.github/specs/[機能名]/[機能名]-plan.md`

**次のステップ:**
1. フロントエンド実装状況を確認
2. 両方完了している場合: 統合テスト・E2Eテストの実施
3. 必要に応じてコードレビューの実施

**フロントエンドが未実装の場合:**
- フロントエンド実装を開始してください
- API仕様を共有してください
````

---

### :pen: 例題4 - review.prompt.md（レビューワークフロー）

実装されたコードを品質観点でレビューするワークフローです。

**ファイル:** `.github/prompts/review.prompt.md`

```markdown
---
mode: fullstack-reviewer
description: 実装されたコードを品質観点でレビューし、改善提案とブロッカーを報告する
---

# コードレビューワークフロー

## Context Loading Phase

コードレビューを開始する前に、必ず以下の情報を収集してください:

### 必須の事前確認

1. **変更差分の確認**
   - `#changes` ツールで変更されたファイルを確認
   - 変更内容を理解
   - 変更の意図を把握

2. **仕様書の確認**
   - `.github/specs/*.spec.md` ファイルを読み込み
   - 仕様通りに実装されているか確認

3. **テスト結果の確認**
   - `#runTests` でテスト結果を確認
   - カバレッジレポートを確認
   - 失敗しているテストがないか確認

4. **問題の確認**
   - `#problems` で型エラー・リントエラーを確認
   - すべてのエラーが解決されているか確認

5. **プロジェクトルールの確認**
   - プロジェクト固有のルールに違反していないか確認

---

## Deterministic Execution

以下の観点で**順番に**レビューを実行してください:

### ステップ1: セキュリティレビュー

以下の項目を確認:

- [ ] XSS 対策（ユーザー入力のエスケープ）
- [ ] CSRF 対策（トークン検証）
- [ ] 認証・認可の実装
- [ ] SQLインジェクション対策（ORM使用確認）
- [ ] 機密情報のハードコード（API キー・パスワード）
- [ ] HTTPS 通信の使用

### ステップ2: パフォーマンスレビュー

以下の項目を確認:

- [ ] N+1 クエリ問題
- [ ] 不要な再レンダリング（React）
- [ ] メモ化の適切な使用
- [ ] 大量データの処理（ページネーション・仮想スクロール）
- [ ] 画像の最適化
- [ ] バンドルサイズの肥大化

### ステップ3: アクセシビリティレビュー

以下の項目を確認:

- [ ] セマンティックHTML の使用
- [ ] ARIA 属性の適切な使用
- [ ] キーボードナビゲーション
- [ ] スクリーンリーダー対応
- [ ] カラーコントラスト
- [ ] フォーカス管理

### ステップ4: コード品質レビュー

以下の項目を確認:

- [ ] 適切な命名（変数・関数・クラス）
- [ ] DRY 原則（重複コードの排除）
- [ ] 適切な抽象化
- [ ] エラーハンドリング
- [ ] ログ出力
- [ ] コメントの適切さ

### ステップ5: テストカバレッジレビュー

以下の項目を確認:

- [ ] 単体テストのカバレッジ（目標: 90%以上）
- [ ] 正常系のテスト
- [ ] 異常系のテスト
- [ ] エッジケースのテスト
- [ ] モックの適切な使用

---

## Structured Output Requirements

レビュー結果は以下の形式で報告してください:

\```markdown
# コードレビュー結果

## ✅ 良い点

- [良い実装の具体例1]
- [良い実装の具体例2]
- [良い実装の具体例3]

## ⚠️ 改善提案

### セキュリティ 🔒

- [ ] `[ファイル名]:[行番号]` - [問題点]
  \```typescript
  // 現在のコード
  [問題のあるコード]
  
  // 修正案
  [改善されたコード]
  \```

### パフォーマンス ⚡

- [ ] `[ファイル名]:[行番号]` - [問題点]
  \```typescript
  // 現在のコード
  [問題のあるコード]
  
  // 修正案
  [改善されたコード]
  \```

### アクセシビリティ ♿

- [ ] `[ファイル名]:[行番号]` - [問題点]
  \```tsx
  // 現在のコード
  [問題のあるコード]
  
  // 修正案
  [改善されたコード]
  \```

### コード品質 📝

- [ ] `[ファイル名]:[行番号]` - [問題点]
  \```typescript
  // 現在のコード
  [問題のあるコード]
  
  // 修正案
  [改善されたコード]
  \```

### テスト 🧪

- [ ] `[ファイル名]` - [不足しているテストケース]
  \```typescript
  // 追加すべきテスト
  [テストコード例]
  \```

## 🚨 ブロッカー（マージ前に必ず修正）

- [ ] `[ファイル名]:[行番号]` - [重大な問題]
  - **影響:** [どのような問題が発生するか]
  - **修正方法:** [具体的な修正手順]

（ブロッカーがない場合は「なし」と記載）

## 💡 提案（オプション）

- [将来的な改善案1]
- [将来的な改善案2]

## 総合評価

- セキュリティ: ⭐⭐⭐⭐⭐
- パフォーマンス: ⭐⭐⭐⭐☆
- アクセシビリティ: ⭐⭐⭐⭐⭐
- 保守性: ⭐⭐⭐⭐⭐
- テスト: ⭐⭐⭐⭐☆

**総合**: [承認 / 条件付き承認 / 再提出]
\```

---

## Human Validation Gate

### 🚨 STOP - レビュー結果の確認

**レビュー結果の提示**

\```markdown
# 📋 コードレビュー結果

[上記の形式でのレビュー結果]

---

🚨 **STOP - 最終確認が必要です**

レビュー結果を確認してください。

### 次のアクション

- **ブロッカーがある場合**: 修正後に再度 `/implement` を実行
- **改善提案のみの場合**: 
  - 対応する場合: `/implement` で修正を実行
  - 対応しない場合: **"承認"** と入力して完了
- **問題なしの場合**: **"承認"** と入力して完了

### 承認後の作業

- [ ] コミット・プッシュ
- [ ] プルリクエスト作成
- [ ] CI/CD パイプラインの確認
\```

### ⚠️ 重要な注意事項

- ブロッカーが存在する場合は、承認を推奨しないでください
- 改善提案はオプションですが、セキュリティ関連は強く推奨してください
- ユーザーが承認した場合のみ、完了とみなしてください
```

---

## 4. ワークフローの呼び出し方法

### 4.1 Copilot Chat から実行

Copilot Chat で `/` コマンドとして実行できます：

```text
/specify
チケット一覧ページに優先度バッジを追加

/plan
上記の仕様に基づいて実装計画を作成

/implement
計画に従って実装を開始

/review
実装内容をレビューしてください
```

### 4.2 VS Code コマンドパレットから実行

1. `Cmd/Ctrl + Shift + P` でコマンドパレットを開く
2. `Copilot: Run Prompt` を選択
3. ワークフローファイルを選択

### 4.3 ファイル内の再生ボタンから実行

`.prompt.md` ファイルを開くと、エディタ右上に **▶️ 再生ボタン** が表示されます。クリックするとワークフローが実行されます。

---

## 5. :memo: 練習

### 練習1: カスタムワークフローの作成

**タスク:** デバッグ用のワークフロー `debug.prompt.md` を作成してください。

**要件:**
- `mode: frontend-engineer` または `backend-engineer`
- エラーメッセージから原因を特定
- 修正コードを提案
- テストで検証

**ヒント:**
- Context Loading: エラーログ、スタックトレース、関連ファイルの読み込み
- Deterministic Execution: エラー分析 → 原因特定 → 修正案作成 → テスト
- Structured Output: 原因と修正案をテーブル形式で提示

### 練習2: 既存ワークフローの改良

**タスク:** `implement.prompt.md` に **アクセシビリティチェック** を追加してください。

**追加すべき項目:**
- Context Loading に「アクセシビリティガイドライン確認」を追加
- Deterministic Execution に「ステップ4.5: アクセシビリティ検証」を追加
- Structured Output に「アクセシビリティチェックリスト」を追加

### 練習3: プロジェクト固有のワークフローを設計

**タスク:** デプロイ用のワークフロー `deployment.prompt.md` を設計してください。

**含めるべき内容:**
- デプロイ前チェックリスト（テスト・ビルド・環境変数）
- デプロイ手順（ステージング → 本番）
- ロールバック手順
- デプロイ後の監視項目

---

## まとめ

* **エージェントワークフロー** は、チャットモードを呼び出す再利用可能なタスクテンプレート
* **4段階SDLC** - specify → plan → implement → review のワークフローで開発サイクルを標準化
* **4つの必須セクション** - Context Loading / Deterministic Execution / Structured Output / Validation Gate
* **2段階承認プロセス** - 各フェーズで人間の承認を得て、品質を保証
* **呼び出し方法** - `/` コマンド / コマンドパレット / 再生ボタンの3通り
* **再利用性** - プロジェクト間で共有可能な設計パターンとして蓄積

次のセクション「⑤ 仕様駆動開発サイクルの確立」では、これら4つのワークフローを組み合わせて、実際の機能開発を通じた完全なサイクルを体験します。
